.TH "include/zos-base.h" 3 "Tue Jan 18 2022" "zoslib" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/zos-base.h
.SH SYNOPSIS
.br
.PP
\fC#include <_Nascii\&.h>\fP
.br
\fC#include <stdarg\&.h>\fP
.br
\fC#include <stdbool\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <sys/__getipc\&.h>\fP
.br
\fC#include <sys/ipc\&.h>\fP
.br
\fC#include <sys/shm\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include 'zos\-bpx\&.h'\fP
.br
\fC#include 'zos\-char\-util\&.h'\fP
.br
\fC#include 'zos\-io\&.h'\fP
.br
\fC#include 'zos\-sys\-info\&.h'\fP
.br
\fC#include 'zos\-tls\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fB__sem\fP"
.br
.ti -1c
.RI "struct \fB__sem_t\fP"
.br
.ti -1c
.RI "struct \fB__stack_info\fP"
.br
.ti -1c
.RI "struct \fB__cpu_relax_workarea\fP"
.br
.ti -1c
.RI "struct \fBzoslib_config\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB__ZOS_EXT__\fP   1"
.br
.ti -1c
.RI "#define \fB__ZOS_CC\fP"
.br
.ti -1c
.RI "#define \fBIPC_CLEANUP_ENVAR_DEFAULT\fP   '__IPC_CLEANUP'"
.br
.ti -1c
.RI "#define \fBDEBUG_ENVAR_DEFAULT\fP   '__RUNDEBUG'"
.br
.ti -1c
.RI "#define \fBRUNTIME_LIMIT_ENVAR_DEFAULT\fP   '__RUNTIMELIMIT'"
.br
.ti -1c
.RI "#define \fBFORKMAX_ENVAR_DEFAULT\fP   '__FORKMAX'"
.br
.ti -1c
.RI "#define \fBCCSID_GUESS_BUF_SIZE_DEFAULT\fP   '__CCSIDGUESSBUFSIZE'"
.br
.ti -1c
.RI "#define \fBUNTAGGED_READ_MODE_DEFAULT\fP   '__UNTAGGED_READ_MODE'"
.br
.ti -1c
.RI "#define \fBUNTAGGED_READ_MODE_CCSID1047_DEFAULT\fP   '__UNTAGGED_READ_MODE_CCSID1047'"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fB__sem\fP \fB____sem_t\fP"
.br
.ti -1c
.RI "typedef struct \fB__stack_info\fP \fB__stack_info\fP"
.br
.ti -1c
.RI "typedef struct \fB__cpu_relax_workarea\fP \fB__crwa_t\fP"
.br
.ti -1c
.RI "typedef struct \fBzoslib_config\fP \fBzoslib_config_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBnotagread_t\fP { \fB__NO_TAG_READ_DEFAULT\fP = 0, \fB__NO_TAG_READ_DEFAULT_WITHWARNING\fP = 1, \fB__NO_TAG_READ_V6\fP = 2, \fB__NO_TAG_READ_STRICT\fP = 3 }"
.br
.ti -1c
.RI "enum \fBclockid_t\fP { \fBCLOCK_REALTIME\fP, \fBCLOCK_MONOTONIC\fP, \fBCLOCK_HIGHRES\fP, \fBCLOCK_THREAD_CPUTIME_ID\fP }"
.br
.ti -1c
.RI "enum \fBCOND_TIME_WAIT_CONSTANTS\fP { \fBCW_INTRPT\fP = 1, \fBCW_CONDVAR\fP = 32 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBclock_gettime\fP (\fBclockid_t\fP clk_id, struct timespec *tp)"
.br
.ti -1c
.RI "char ** \fB__get_environ_np\fP (void)"
.br
.ti -1c
.RI "void \fB__xfer_env\fP (void)"
.br
.ti -1c
.RI "void \fB__cleanupipc\fP (int others)"
.br
.ti -1c
.RI "const char * \fBgetIFAUsageErrorString\fP (unsigned long \fBrc\fP)"
.br
.ti -1c
.RI "unsigned long long \fB__registerProduct\fP (const char *major_version, const char *product_owner, const char *feature_name, const char *product_name, const char *pid)"
.br
.ti -1c
.RI "unsigned int \fBatomic_dec\fP (volatile unsigned int *loc)"
.br
.ti -1c
.RI "unsigned int \fBatomic_inc\fP (volatile unsigned int *loc)"
.br
.ti -1c
.RI "int \fBgettid\fP ()"
.br
.ti -1c
.RI "void \fB__display_backtrace\fP (int fd)"
.br
.ti -1c
.RI "int \fBexecvpe\fP (const char *name, char *const argv[], char *const envp[])"
.br
.ti -1c
.RI "int \fBbacktrace\fP (void **buffer, int size)"
.br
.ti -1c
.RI "char ** \fBbacktrace_symbols\fP (void *const *buffer, int size)"
.br
.ti -1c
.RI "void \fBbacktrace_symbols_fd\fP (void *const *buffer, int size, int fd)"
.br
.ti -1c
.RI "void \fB__abend\fP (int comp_code, unsigned reason_code, int flat_byte, void *\fBplist\fP)"
.br
.ti -1c
.RI "int \fBstrncasecmp_ignorecp\fP (const char *a, const char *b, size_t n)"
.br
.ti -1c
.RI "int \fBstrcasecmp_ignorecp\fP (const char *a, const char *b)"
.br
.ti -1c
.RI "int \fB__indebug\fP (void)"
.br
.ti -1c
.RI "void \fB__setdebug\fP (int)"
.br
.ti -1c
.RI "int \fB__getargcv\fP (int *argc, char ***argv, pid_t pid)"
.br
.ti -1c
.RI "int \fB__getexepath\fP (char *path, int pathlen, pid_t pid)"
.br
.ti -1c
.RI "char ** \fB__getargv\fP (void)"
.br
.ti -1c
.RI "int \fB__getargc\fP (void)"
.br
.ti -1c
.RI "int * \fB__get_stack_start\fP ()"
.br
.ti -1c
.RI "void * \fB__iterate_stack_and_get\fP (void *dsaptr, \fB__stack_info\fP *si)"
.br
.ti -1c
.RI "bool \fB__is_stfle_available\fP ()"
.br
.ti -1c
.RI "void * \fB__dlcb_next\fP (void *last)"
.br
.ti -1c
.RI "int \fB__dlcb_entry_name\fP (char *buf, int size, void *dlcb)"
.br
.ti -1c
.RI "void * \fB__dlcb_entry_addr\fP (void *dlcb)"
.br
.ti -1c
.RI "unsigned long \fB__mach_absolute_time\fP (void)"
.br
.ti -1c
.RI "void * \fBanon_mmap\fP (void *_, size_t len)"
.br
.ti -1c
.RI "void * \fBroanon_mmap\fP (void *_, size_t len, int prot, int flags, const char *filename, int fildes, off_t off)"
.br
.ti -1c
.RI "int \fBanon_munmap\fP (void *addr, size_t len)"
.br
.ti -1c
.RI "int \fB__cond_timed_wait\fP (unsigned int secs, unsigned int nsecs, unsigned int event_list, unsigned int *secs_rem, unsigned int *nsecs_rem)"
.br
.ti -1c
.RI "int \fB__fork\fP (void)"
.br
.ti -1c
.RI "int \fBgetentropy\fP (void *buffer, size_t length)"
.br
.ti -1c
.RI "void \fB__build_version\fP (void)"
.br
.ti -1c
.RI "size_t \fBstrnlen\fP (const char *str, size_t maxlen)"
.br
.ti -1c
.RI "void \fB__tcp_clear_to_close\fP (int socket, unsigned int secs)"
.br
.ti -1c
.RI "int \fBget_ipcs_overview\fP (IPCQPROC *info)"
.br
.ti -1c
.RI "int \fB__print_zoslib_help\fP (FILE *fp, const char *title)"
.br
.ti -1c
.RI "void \fB__cpu_relax\fP (\fB__crwa_t\fP *)"
.br
.ti -1c
.RI "int \fB__sem_init\fP (\fB__sem_t\fP *s0, int shared, unsigned int val)"
.br
.ti -1c
.RI "int \fB__sem_post\fP (\fB__sem_t\fP *s0)"
.br
.ti -1c
.RI "int \fB__sem_trywait\fP (\fB____sem_t\fP *s0)"
.br
.ti -1c
.RI "int \fB__sem_timedwait\fP (\fB____sem_t\fP *s0, const struct timespec *abs_timeout)"
.br
.ti -1c
.RI "int \fB__sem_wait\fP (\fB__sem_t\fP *s0)"
.br
.ti -1c
.RI "int \fB__sem_getvalue\fP (\fB__sem_t\fP *s0, int *sval)"
.br
.ti -1c
.RI "int \fB__sem_destroy\fP (\fB__sem_t\fP *s0)"
.br
.ti -1c
.RI "int \fB__testread\fP (const void *location)"
.br
.ti -1c
.RI "void \fB__tb\fP (void)"
.br
.ti -1c
.RI "\fBnotagread_t\fP \fB__get_no_tag_read_behaviour\fP ()"
.br
.ti -1c
.RI "int \fB__get_no_tag_ignore_ccsid1047\fP ()"
.br
.ti -1c
.RI "void \fBinit_zoslib\fP (const \fBzoslib_config_t\fP config)"
.br
.ti -1c
.RI "void \fBinit_zoslib_config\fP (\fBzoslib_config_t\fP *const config)"
.br
.ti -1c
.RI "int \fBnanosleep\fP (const struct timespec *req, struct timespec *rem)"
.br
.ti -1c
.RI "int \fB__lutimes\fP (const char *filename, const struct timeval tv[2])"
.br
.ti -1c
.RI "int \fB__update_envar_settings\fP (const char *envar)"
.br
.ti -1c
.RI "int \fB__update_envar_names\fP (\fBzoslib_config_t\fP *const config)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const char * \fB__zoslib_version\fP"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define __ZOS_CC"

.SS "#define __ZOS_EXT__   1"

.SS "#define CCSID_GUESS_BUF_SIZE_DEFAULT   '__CCSIDGUESSBUFSIZE'"

.SS "#define DEBUG_ENVAR_DEFAULT   '__RUNDEBUG'"

.SS "#define FORKMAX_ENVAR_DEFAULT   '__FORKMAX'"

.SS "#define IPC_CLEANUP_ENVAR_DEFAULT   '__IPC_CLEANUP'"

.SS "#define RUNTIME_LIMIT_ENVAR_DEFAULT   '__RUNTIMELIMIT'"

.SS "#define UNTAGGED_READ_MODE_CCSID1047_DEFAULT   '__UNTAGGED_READ_MODE_CCSID1047'"

.SS "#define UNTAGGED_READ_MODE_DEFAULT   '__UNTAGGED_READ_MODE'"

.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fB__sem\fP \fB____sem_t\fP"

.SS "typedef struct \fB__cpu_relax_workarea\fP \fB__crwa_t\fP"

.SS "typedef struct \fB__stack_info\fP \fB__stack_info\fP"

.SS "typedef struct \fBzoslib_config\fP \fBzoslib_config_t\fP"
Configuration for zoslib library 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBclockid_t\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fICLOCK_REALTIME \fP\fP
.TP
\fB\fICLOCK_MONOTONIC \fP\fP
.TP
\fB\fICLOCK_HIGHRES \fP\fP
.TP
\fB\fICLOCK_THREAD_CPUTIME_ID \fP\fP
.SS "enum \fBCOND_TIME_WAIT_CONSTANTS\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fICW_INTRPT \fP\fP
.TP
\fB\fICW_CONDVAR \fP\fP
.SS "enum \fBnotagread_t\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fI__NO_TAG_READ_DEFAULT \fP\fP
.TP
\fB\fI__NO_TAG_READ_DEFAULT_WITHWARNING \fP\fP
.TP
\fB\fI__NO_TAG_READ_V6 \fP\fP
.TP
\fB\fI__NO_TAG_READ_STRICT \fP\fP
.SH "Function Documentation"
.PP 
.SS "void __abend (int comp_code, unsigned reason_code, int flat_byte, void * plist)"
Generates an SVC 13 abend\&. 
.PP
\fBParameters\fP
.RS 4
\fIcomp_code\fP Completion code\&. 
.br
\fIreason_code\fP Reason code\&. 
.br
\fIflat_byte\fP Flat Byte\&. 
.br
\fIplist\fP Parameter list\&. 
.RE
.PP

.SS "void __build_version (void)"
Prints the build version of the library 
.SS "void __cleanupipc (int others)"
Remove IPC semaphores and shared memory\&. 
.PP
\fBParameters\fP
.RS 4
\fIothers\fP non-zero value indicates remove IPC not associated with current process\&. 
.RE
.PP

.SS "int __cond_timed_wait (unsigned int secs, unsigned int nsecs, unsigned int event_list, unsigned int * secs_rem, unsigned int * nsecs_rem)"
Suspend the calling thread until any one of a set of events has occurred or until a specified amount of time has passed\&. 
.PP
\fBParameters\fP
.RS 4
\fIsecs\fP seconds to suspend 
.br
\fInsecs\fP nanoseconds to suspend 
.br
\fIevent_list\fP events that will trigger thread to resume (CW_INTRPT or CW_CONDVAR) 
.br
\fIsecs_rem\fP seconds remaining 
.br
\fInsecs_rem\fP nanoseconds remaining 
.RE
.PP
\fBReturns\fP
.RS 4
returns 0 if successful, -1 if unsuccessful\&. 
.RE
.PP

.SS "void __cpu_relax (\fB__crwa_t\fP *)"
TODO(itodorov) - zos: document these interfaces 
.SS "void __display_backtrace (int fd)"
Print backtrace of stack to file descriptor\&. 
.PP
\fBParameters\fP
.RS 4
\fIfd\fP file descriptor\&. 
.RE
.PP

.SS "void* __dlcb_entry_addr (void * dlcb)"
Get address of dlcb entry 
.PP
\fBParameters\fP
.RS 4
\fIdlcb\fP - current dlcb 
.RE
.PP
\fBReturns\fP
.RS 4
returns entry address of dlcb 
.RE
.PP

.SS "int __dlcb_entry_name (char * buf, int size, void * dlcb)"
Get entry name of given dlcb 
.PP
\fBParameters\fP
.RS 4
\fIbuf\fP - DLL name of given dlcb 
.br
\fIsize\fP - maximum number of bytes 
.br
\fIdlcb\fP - current dlcb 
.RE
.PP
\fBReturns\fP
.RS 4
[in] number of bytes written to buf 
.RE
.PP

.SS "void* __dlcb_next (void * last)"
Get next dlcb entry 
.PP
\fBParameters\fP
.RS 4
\fIlast\fP - previous dlcb entry 
.RE
.PP
\fBReturns\fP
.RS 4
[in] returns next dlcb entry 
.RE
.PP

.SS "int __fork (void)"
Create a child process 
.PP
\fBReturns\fP
.RS 4
On success, the PID of the child process is returned in the parent, and 0 is returned in the child\&. On failure, -1 is returned in the parent, no child process is created, and errno is set appropriately\&. 
.RE
.PP

.SS "char** __get_environ_np (void)"
Get the environ\&. 
.PP
\fBReturns\fP
.RS 4
returns pointer to environment list 
.RE
.PP

.SS "int __get_no_tag_ignore_ccsid1047 ()"

.SS "\fBnotagread_t\fP __get_no_tag_read_behaviour ()"

.SS "int* __get_stack_start ()"
Get the stack start address for the current thread 
.PP
\fBReturns\fP
.RS 4
returns the stack start address 
.RE
.PP

.SS "int __getargc (void)"
Get program argument count of the current process 
.PP
\fBReturns\fP
.RS 4
returns count of process arguments 
.RE
.PP

.SS "int __getargcv (int * argc, char *** argv, pid_t pid)"
Get program argument list of a given process id 
.PP
\fBParameters\fP
.RS 4
\fIargc\fP - pointer to store count of the arguments 
.br
\fIargv\fP - pointer to store an array of pointers that point to each argument 
.br
\fIpid\fP - process id to obtain the argc and argv for 
.RE
.PP
\fBNote\fP
.RS 4
Call free(argv) when done accessing argv\&. 
.RE
.PP
\fBReturns\fP
.RS 4
On success, returns 0, or -1 on error\&. 
.RE
.PP

.SS "char** __getargv (void)"
Get program argument list of the current process 
.PP
\fBReturns\fP
.RS 4
returns an array of process arguments 
.RE
.PP

.SS "int __getexepath (char * path, int pathlen, pid_t pid)"
Get the executable path of a given process id 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP - pointer to the destination array to copy the null-terminated path to 
.br
\fIpathlen\fP - length of the given array 
.br
\fIpid\fP - process id to obtain the executable path for 
.RE
.PP
\fBReturns\fP
.RS 4
On success, returns 0, or -1 on error\&. 
.RE
.PP

.SS "int __indebug (void)"
Indicates if zoslib is in debug mode 
.PP
\fBReturns\fP
.RS 4
returns current debug mode 
.RE
.PP

.SS "bool __is_stfle_available ()"
Check if STFLE (STORE FACILITY LIST EXTENDED) instruction is available 
.PP
\fBReturns\fP
.RS 4
true if the STFLE instruction is available 
.RE
.PP

.SS "void* __iterate_stack_and_get (void * dsaptr, \fB__stack_info\fP * si)"
Iterate to next stack dsa based on current dsa 
.PP
\fBParameters\fP
.RS 4
\fIdsaptr\fP - current dsa entry 
.br
\fIsi\fP - stack information of next dsa 
.RE
.PP
\fBReturns\fP
.RS 4
returns the next dsa entry in the chain or 0 if not found 
.RE
.PP

.SS "int __lutimes (const char * filename, const struct timeval tv[2])"
Changes the access and modification times of a file in the same way as lutimes, with the difference that microsecond precision is not supported\&. 
.PP
\fBParameters\fP
.RS 4
\fIfilename\fP the path to file 
.br
\fItv\fP two structs used to specify the new times 
.RE
.PP

.SS "unsigned long __mach_absolute_time (void)"
Obtain the mach absolute time 
.PP
\fBReturns\fP
.RS 4
returns mach absolute time 
.RE
.PP

.SS "int __print_zoslib_help (FILE * fp, const char * title)"
Prints zoslib help information to specified FILE pointer 
.PP
\fBParameters\fP
.RS 4
\fIFILE\fP pointer to write to 
.br
\fItitle\fP header, specify NULL for default 
.RE
.PP
\fBReturns\fP
.RS 4
On success, returns 0, or < 0 on error\&. 
.RE
.PP

.SS "unsigned long long __registerProduct (const char * major_version, const char * product_owner, const char * feature_name, const char * product_name, const char * pid)"
Registers product for SMF 89 Type 1 records using IFAUSAGE macro\&. 
.PP
\fBParameters\fP
.RS 4
\fImajor_version\fP The major version of Product (e\&.g\&. 14) 
.br
\fIproduct_owner\fP The product owner (e\&.g\&. IBM) 
.br
\fIfeature_name\fP The feature name (e\&.g\&. Node\&.js) 
.br
\fIproduct_name\fP The product name (e\&.g\&. Node\&.js for z/OS) 
.br
\fIpid\fP The Product ID (e\&.g\&. 5676-SDK) 
.RE
.PP
\fBReturns\fP
.RS 4
returns 0 if successful, non-zero if unsuccessful\&. 
.RE
.PP

.SS "int __sem_destroy (\fB__sem_t\fP * s0)"

.SS "int __sem_getvalue (\fB__sem_t\fP * s0, int * sval)"

.SS "int __sem_init (\fB__sem_t\fP * s0, int shared, unsigned int val)"

.SS "int __sem_post (\fB__sem_t\fP * s0)"

.SS "int __sem_timedwait (\fB____sem_t\fP * s0, const struct timespec * abs_timeout)"

.SS "int __sem_trywait (\fB____sem_t\fP * s0)"

.SS "int __sem_wait (\fB__sem_t\fP * s0)"

.SS "void __setdebug (int)"
Activates debug mode 
.SS "void __tb (void)"

.SS "void __tcp_clear_to_close (int socket, unsigned int secs)"
Attempts to a close a socket for a period of time 
.PP
\fBParameters\fP
.RS 4
\fIsocket\fP socket handle 
.br
\fIsecs\fP number of seconds to attempt the close 
.RE
.PP

.SS "int __testread (const void * location)"
TODO(itodorov) - zos: document these interfaces 
.SS "int __update_envar_names (\fBzoslib_config_t\fP *const config)"
Changes the names of one or more of the environment variables zoslib uses 
.PP
\fBParameters\fP
.RS 4
\fIzoslib_confit_t\fP structure that defines the new environment variable name(s) 
.RE
.PP
\fBReturns\fP
.RS 4
0 for success, or -1 for failure 
.RE
.PP

.SS "int __update_envar_settings (const char * envar)"
Updates the zoslib global variables associated with the zoslib environment variables
.PP
\fBParameters\fP
.RS 4
\fIenvar\fP environment variable to update, specify NULL to update all 
.RE
.PP
\fBReturns\fP
.RS 4
0 for success, or -1 for failure 
.RE
.PP

.SS "void __xfer_env (void)"
Convert environment variables from EBCDIC to ASCII\&. 
.SS "void* anon_mmap (void * _, size_t len)"
Generate an anonymous memory map 
.PP
\fBParameters\fP
.RS 4
\fI_\fP ignored 
.br
\fIlen\fP length in bytes of memory map 
.RE
.PP
\fBReturns\fP
.RS 4
returns start address of anonymous memory map 
.RE
.PP

.SS "int anon_munmap (void * addr, size_t len)"
Deallocates memory map 
.PP
\fBParameters\fP
.RS 4
\fIaddr\fP start address of memory map 
.br
\fIlen\fP length in bytes 
.RE
.PP
\fBReturns\fP
.RS 4
returns 0 if successful, -1 if unsuccessful\&. 
.RE
.PP

.SS "unsigned int atomic_dec (volatile unsigned int * loc)"

.SS "unsigned int atomic_inc (volatile unsigned int * loc)"

.SS "int backtrace (void ** buffer, int size)"
Generate a backtrace and store into *Buffer\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP Address of location to store backtrace to\&. 
.br
\fIsize\fP Maximum number of bytes to store\&. 
.RE
.PP
\fBReturns\fP
.RS 4
if successful, returns 0, otherwise -1 
.RE
.PP

.SS "char** backtrace_symbols (void *const * buffer, int size)"
Generate a backtrace symbols and store into *Buffer\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP Address of location to store backtrace to\&. 
.br
\fIsize\fP Maximum number of bytes to store\&. 
.RE
.PP
\fBReturns\fP
.RS 4
if successful, an array of strings, otherwise returns NULL\&. 
.RE
.PP

.SS "void backtrace_symbols_fd (void *const * buffer, int size, int fd)"
Generate a backtrace symbols and store into *Buffer\&. 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP Address of location to store backtrace to\&. 
.br
\fIsize\fP Maximum number of bytes to store\&. 
.br
\fIfd\fP file descriptor\&. 
.RE
.PP

.SS "int clock_gettime (\fBclockid_t\fP clk_id, struct timespec * tp)"
Get current time of clock\&. 
.PP
\fBParameters\fP
.RS 4
\fIclk_id\fP Clock id\&. 
.br
\fItp\fP structure to store the current time to\&. 
.RE
.PP
\fBReturns\fP
.RS 4
return 0 for success, or -1 for failure\&. 
.RE
.PP

.SS "int execvpe (const char * name, char *const argv[], char *const envp[])"
Execute a file\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP used to construct a pathname that identifies the new process image file\&. 
.br
\fIargv\fP an array of character pointers to NULL-terminated strings\&. 
.br
\fIenvp\fP an array of character pointers to NULL-terminated strings\&. 
.RE
.PP
\fBReturns\fP
.RS 4
if successful, it doesn't return; otherwise, it returns -1 and sets errno\&. 
.RE
.PP

.SS "int get_ipcs_overview (IPCQPROC * info)"
Returns the overview structure of IPCQPROC 
.PP
\fBParameters\fP
.RS 4
\fIinfo\fP address of allocated IPCQPROC structure 
.RE
.PP
\fBReturns\fP
.RS 4
On success, returns 0, or -1 on error\&. 
.RE
.PP

.SS "int getentropy (void * buffer, size_t length)"
Fill a buffer with random bytes 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP to store random bytes to\&. 
.br
\fInumber\fP of random bytes to generate\&. 
.RE
.PP
\fBReturns\fP
.RS 4
On success, returns 0, or -1 on error\&. 
.RE
.PP

.SS "const char* getIFAUsageErrorString (unsigned long rc)"
Retrieves error message from __registerProduct IFAUSAGE macro\&. 
.PP
\fBParameters\fP
.RS 4
\fIrc\fP return code from __registerProduct\&. 
.RE
.PP
\fBReturns\fP
.RS 4
returns error message as C character string\&. 
.RE
.PP

.SS "int gettid ()"
Get the Thread ID\&. 
.PP
\fBReturns\fP
.RS 4
returns the current thread id 
.RE
.PP

.SS "void init_zoslib (const \fBzoslib_config_t\fP config)"
Initialize zoslib library 
.PP
\fBParameters\fP
.RS 4
\fIconfig\fP struct to configure zoslib\&. 
.RE
.PP

.SS "void init_zoslib_config (\fBzoslib_config_t\fP *const config)"
Initialize the struct used to configure zoslib with default values\&. 
.PP
\fBParameters\fP
.RS 4
\fIconfig\fP struct to configure zoslib\&. 
.RE
.PP

.SS "int nanosleep (const struct timespec * req, struct timespec * rem)"
Suspends the execution of the calling thread until either at least the time specified in *req has elapsed, an event occurs, or a signal arrives\&. 
.PP
\fBParameters\fP
.RS 4
\fIreq\fP struct used to specify intervals of time with nanosecond precision 
.br
\fIrem\fP the remaining time if the call is interrupted 
.RE
.PP

.SS "void* roanon_mmap (void * _, size_t len, int prot, int flags, const char * filename, int fildes, off_t off)"
Generate a read only anonymous memory map for a given file 
.PP
\fBParameters\fP
.RS 4
\fI_\fP ignored 
.br
\fIlen\fP length in bytes of memory map 
.br
\fIprot\fP protection bits 
.br
\fIflags\fP mmap flags 
.br
\fIfilename\fP filename to read 
.br
\fIfiledes\fP file descriptor 
.RE
.PP
\fBReturns\fP
.RS 4
returns start address of anonymous memory map 
.RE
.PP

.SS "int strcasecmp_ignorecp (const char * a, const char * b)"
String case comparision that ignores code page\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP - null-terminated character string\&. 
.br
\fIb\fP - null-terminated character string\&. 
.RE
.PP
\fBReturns\fP
.RS 4
if equal, returns 0, otherwise returns non-zero\&. 
.RE
.PP

.SS "int strncasecmp_ignorecp (const char * a, const char * b, size_t n)"
String case comparision that ignores code page\&. 
.PP
\fBParameters\fP
.RS 4
\fIa\fP - Character String\&. 
.br
\fIb\fP - Character String\&. 
.br
\fIn\fP - Number of bytes to compare\&. 
.RE
.PP
\fBReturns\fP
.RS 4
if equal, returns 0, otherwise returns non-zero\&. 
.RE
.PP

.SS "size_t strnlen (const char * str, size_t maxlen)"
Determine the length of a fixed-size string 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP fixed-size character string 
.br
\fImaxlen\fP maximum # of bytes to traverse 
.RE
.PP
\fBReturns\fP
.RS 4
returns the length of the string 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "const char* __zoslib_version\fC [extern]\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for zoslib from the source code\&.
